*** Begin Patch
*** Update File: src/components/TranslateGame.jsx
@@
-async function prefetch(size = 5, timeoutMs = 8000) {
+async function prefetch(size = 5, timeoutMs = 20000) {
   const key = queueKey({ difficulty, unit, chapter, direction });
   const q = queuesRef.current.get(key) || [];
   if (q.length >= size) return;
   const controller = new AbortController();
   const t = setTimeout(() => controller.abort(), timeoutMs);
   try {
     const r = await fetch(`${API_BASE}/api/sentence-bundle`, {
       method: 'POST',
       headers: { 'Content-Type': 'application/json' },
       body: JSON.stringify({ difficulty, unit, chapter, size, direction }),
       signal: controller.signal
     });
     clearTimeout(t);
     if (!r.ok) throw new Error('bundle failed');
     const data = await r.json();
     (data?.items || []).forEach(it => q.push(it));
     queuesRef.current.set(key, q);
   } catch (err) {
-    console.warn('prefetch error', err);
+    console.warn('prefetch error', err);
+    // Light retry once
+    try {
+      await new Promise(res => setTimeout(res, 300));
+      const r2 = await fetch(`${API_BASE}/api/sentence-bundle`, {
+        method: 'POST',
+        headers: { 'Content-Type': 'application/json' },
+        body: JSON.stringify({ difficulty, unit, chapter, size: Math.max(1, Math.floor(size/2)), direction }),
+      });
+      if (r2.ok) {
+        const data2 = await r2.json();
+        (data2?.items || []).forEach(it => q.push(it));
+        queuesRef.current.set(key, q);
+        return;
+      }
+    } catch {}
+    // Fallback to single sentence
+    try {
+      const one = await fetch(`${API_BASE}/api/sentence`, {
+        method: 'POST',
+        headers: { 'Content-Type': 'application/json' },
+        body: JSON.stringify({ difficulty, unit, chapter, direction }),
+      });
+      if (one.ok) {
+        const j = await one.json();
+        q.push(j);
+        queuesRef.current.set(key, q);
+      }
+    } catch {}
   }
 }
*** End Patch
